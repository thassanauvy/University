from pathlib import Path
import random
import numpy as np

# Define parameters
MUTATION_RATE = 0.05

# Define constraints for genes
GENE_RANGES = {
    "stop_loss": (1, 10),      # 1% to 10% range for stop loss
    "take_profit": (2, 15),    # 2% to 15% range for take profit
    "trade_size": (5, 50)      # 5% to 50% range for trade size
}

def parse_input_file(file_path):
    """Parse the input file to extract parameters."""
    data = {}
    
    with open(file_path, 'r') as file:
        content = file.read()
        
        # Extract initial capital
        capital_line = content.split('"Capital to Start With": $')[1].split('\n')[0]
        data['initial_capital'] = float(capital_line)
        
        # Extract historical prices
        prices_line = content.split('"historical_prices": [')[1].split('],')[0]
        data['historical_prices'] = [float(price) for price in prices_line.split(',')]
        
        # Extract initial population
        population_start = content.find('"initial_population": [') + len('"initial_population": [')
        population_end = content.find('],', population_start)
        population_text = content[population_start:population_end].strip()
        
        # Parse chromosome strings
        chromosomes = []
        for chrom_text in population_text.split('},'):
            if not chrom_text.strip():
                continue
                
            # Clean up the text
            if not chrom_text.endswith('}'):
                chrom_text += '}'
            
            # Extract values
            stop_loss = float(chrom_text.split('"stop_loss": ')[1].split(',')[0])
            take_profit = float(chrom_text.split('"take_profit": ')[1].split(',')[0])
            trade_size = float(chrom_text.split('"trade_size": ')[1].split('}')[0])
            
            chromosomes.append({
                "stop_loss": stop_loss, 
                "take_profit": take_profit, 
                "trade_size": trade_size
            })
            
        data['initial_population'] = chromosomes
        
        # Extract generations
        generations_line = content.split('"generations": ')[1].split('\n')[0]
        data['generations'] = int(generations_line)
        
    return data

def chromosome_to_string(chromosome):
    """Convert a chromosome dictionary to its string representation."""
    stop_loss = str(int(chromosome["stop_loss"] * 10)).zfill(2)
    take_profit = str(int(chromosome["take_profit"] * 10)).zfill(2)
    trade_size = str(int(chromosome["trade_size"])).zfill(2)
    return stop_loss + take_profit + trade_size

def string_to_chromosome(string):
    """Convert a string representation back to a chromosome dictionary."""
    stop_loss = int(string[0:2]) / 10
    take_profit = int(string[2:4]) / 10
    trade_size = int(string[4:6])
    return {"stop_loss": stop_loss, "take_profit": take_profit, "trade_size": trade_size}

def calculate_fitness(chromosome, historical_prices, initial_capital):
    """
    Calculate the fitness (profit) of a trading strategy.
    
    Args:
        chromosome: A dictionary containing stop_loss, take_profit, and trade_size
        historical_prices: List of historical price changes
        initial_capital: Starting capital
        
    Returns:
        float: The profit generated by the strategy
    """
    stop_loss = chromosome["stop_loss"]
    take_profit = chromosome["take_profit"]
    trade_size = chromosome["trade_size"]
    
    capital = initial_capital
    
    for price_change in historical_prices:
        # Calculate the trade amount
        trade_amount = capital * (trade_size / 100)
        
        # Determine profit/loss based on stop-loss and take-profit rules
        if price_change <= -stop_loss:
            # Stop-loss triggered
            profit_loss = -trade_amount * (stop_loss / 100)
        elif price_change >= take_profit:
            # Take-profit triggered
            profit_loss = trade_amount * (take_profit / 100)
        else:
            # Normal trade
            profit_loss = trade_amount * (price_change / 100)
        
        # Update capital
        capital += profit_loss
    
    # Fitness is the profit
    fitness = capital - initial_capital
    return fitness

def select_parents(population, fitnesses):
    """Randomly select two parents from the population."""
    parents = random.sample(population, 2)
    return parents

def single_point_crossover(parent1, parent2):
    """Perform single-point crossover between two parents."""
    # Convert to string representation
    parent1_str = chromosome_to_string(parent1)
    parent2_str = chromosome_to_string(parent2)
    
    # Select a random crossover point
    crossover_point = random.randint(1, len(parent1_str) - 1)
    
    # Create offspring
    offspring1_str = parent1_str[:crossover_point] + parent2_str[crossover_point:]
    offspring2_str = parent2_str[:crossover_point] + parent1_str[crossover_point:]
    
    # Convert back to chromosome dictionaries
    offspring1 = string_to_chromosome(offspring1_str)
    offspring2 = string_to_chromosome(offspring2_str)
    
    return offspring1, offspring2

def mutate(chromosome):
    """Introduce random mutations to a chromosome."""
    # Convert to string for easier mutation
    chromosome_str = chromosome_to_string(chromosome)
    mutated_str = list(chromosome_str)
    
    # Mutate each gene with a small probability
    for i in range(len(mutated_str)):
        if random.random() < MUTATION_RATE:
            # Replace with a random digit
            mutated_str[i] = str(random.randint(0, 9))
    
    mutated_str = ''.join(mutated_str)
    
    # Convert back to chromosome dictionary
    mutated_chromosome = string_to_chromosome(mutated_str)
    
    # Ensure values are within valid ranges
    for key, (min_val, max_val) in GENE_RANGES.items():
        if mutated_chromosome[key] < min_val:
            mutated_chromosome[key] = min_val
        elif mutated_chromosome[key] > max_val:
            mutated_chromosome[key] = max_val
    
    return mutated_chromosome

def genetic_algorithm(initial_population, historical_prices, initial_capital, generations, population_size):
    """Main genetic algorithm function."""
    # Initialize population
    population = initial_population
    
    # Track the best chromosome and its fitness
    best_chromosome = None
    best_fitness = float('-inf')
    
    # Evolution over generations
    for gen in range(generations):
        # Calculate fitness for each chromosome
        fitnesses = [calculate_fitness(chromosome, historical_prices, initial_capital) for chromosome in population]
        
        # Find the best chromosome in this generation
        gen_best_idx = np.argmax(fitnesses)
        gen_best_chromosome = population[gen_best_idx]
        gen_best_fitness = fitnesses[gen_best_idx]
        
        # Update overall best if better
        if gen_best_fitness > best_fitness:
            best_chromosome = gen_best_chromosome
            best_fitness = gen_best_fitness
        
        # Create new population
        new_population = []
        
        # Elitism: keep the best chromosome
        new_population.append(gen_best_chromosome)
        
        # Fill the rest of the population with offspring
        while len(new_population) < population_size:
            # Select parents
            parents = select_parents(population, fitnesses)
            
            # Crossover
            offspring1, offspring2 = single_point_crossover(parents[0], parents[1])
            
            # Mutation
            offspring1 = mutate(offspring1)
            offspring2 = mutate(offspring2)
            
            # Add to new population
            new_population.append(offspring1)
            
            # Only add second offspring if there's room
            if len(new_population) < population_size:
                new_population.append(offspring2)
        
        # Replace old population
        population = new_population
    
    # Return the best strategy and its profit
    return best_chromosome, best_fitness

def main():
    # Get the file path using Pathlib
    home = Path.home()/"Documents/University/Spring '25/CSE422/input2_1.txt"
    
    # Parse input file
    data = parse_input_file(home)
    
    # Run the genetic algorithm
    best_strategy, final_profit = genetic_algorithm(
        data['initial_population'], 
        data['historical_prices'], 
        data['initial_capital'],
        data['generations'],
        len(data['initial_population'])
    )
    
    # Print the results in the required format
    print('"best_strategy":')
    print(f"{{ \"stop_loss\": {best_strategy['stop_loss']}, \"take_profit\": {best_strategy['take_profit']}, \"trade_size\": {best_strategy['trade_size']} }},")
    print(f"\"Final_profit\" : {final_profit}")

if __name__ == "__main__":
    main()